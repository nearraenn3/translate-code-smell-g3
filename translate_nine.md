# Dispensables
เป็นสิ่งที่ไม่มีจุดหมายและไม่จำเป็นแต่จะจัดระเบียบโค้ดให้มีประสิทธิภาพและเข้าใจง่ายขึ้น
# Comments
## Signs and Symptoms(สัญญาณและอาการ)
* เป็นวิธีการเต็มที่ไปด้วยความคิดเห็นเชิงอธิบาย
## Reasons for the Problems(สาเหตุของปัญหา)
* Commentsมักถูกสร้างขึ้นเมื่อผู้เขียนตระหนักว่าโค้ดของตนเข้าใจได้ยากหรือไม่ชัดเจน ในกรณีเช่นนี้ความคิดเห็นเปรียบเสมือนน้ำยาดับกลิ่นที่ปกปิดกลิ่นคาวซึ่งจะทำให้ทุกอย่างดีขึ้น
หากคุณรู้สึกว่าไม่สามารถเข้าใจส่วนของโค้ดได้หากไม่มีComments ให้ลองเปลี่ยนโครงสร้างโค้ดในลักษณะที่ไม่จำเป็นต้องแสดงความคิดเห็น
## Treatment (การรักษา)
* หากข้อคิดเห็นมีวัตถุประสงค์เพื่ออธิบายส่วนที่ซับซ้อน ควรแบ่งออกเป็นส่วนย่อยที่เข้าใจได้โดยใช้Extract Variable.
* หากCommentsอธิบายถึงส่วนของโค้ดส่วนนี้สามารถเปลี่ยนเป็นวิธีการแยกจากกันได้ โดยใช้ Extract Method. โดยชื่อของวิธีการใหม่สามารถนำมาจากข้อความCommentsเอง
* หากมีการแยกวิธีการไปแล้ว แต่Commentsยังคงจำเป็นในการอธิบายว่าวิธีการนี้ทำอะไรให้ตั้งชื่อวิธีการที่อธิบายตนเองได้ ให้ใช้วิธีเปลี่ยนชื่อแทน
* หากคุณต้องการยืนยันกฎเกี่ยวกับสถานะที่จำเป็นสำหรับระบบในการทำงาน ให้ใช้วิธีIntroduce Assertion(แนะนำการยืนยัน).
## Payoff (ผลตอบแทน)
* โค้ดใช้งานง่ายและชัดเจนมากขึ้น
## When to Ignore (เมื่อใดควรละเว้น)
บางครั้งความคิดเห็นอาจเป็นประโยชน์:
  * เมื่อต้องการอธิบายว่าเหตุใดจึงมีการนำบางสิ่งไปใช้ในลักษณะเฉพาะ
  * เมื่ออธิบายอัลกอริทึมที่ซับซ้อน (เมื่อมีการลองใช้วิธีอื่นๆ ทั้งหมดในการทำให้อัลกอริทึมง่ายขึ้นและสรุปได้สั้นๆ )
# Duplicate Code
## Signs and Symptoms(สัญญาณและอาการ)
* โค้ดสองส่วนมีลักษณะเกือบเหมือนกัน
## Reasons for the Problem(สาเหตุของปัญหา)
* การทำสำเนามักเกิดขึ้นเมื่อโปรแกรมเมอร์หลายคนทำงานในส่วนต่างๆของโปรแกรมเดียวกันในเวลาเดียวกัน เนื่องจากพวกเขาทำงานกันคนละงานจึงอาจไม่รู้ว่าเพื่อนร่วมงานของตนได้เขียนโค้ดที่คล้ายกันซึ่งสามารถนำมาใช้ใหม่ได้ตามความต้องการของตนเอง 
นอกจากนี้ยังมีการทำซ้ำที่ละเอียดยิ่งขึ้นเมื่อบางส่วนของโค้ดดูแตกต่างกัน แต่ทำงานเหมือนกันจริงๆ ซึ่งการทำซ้ำแบบนี้หาและแก้ไขได้ยาก 
บางครั้งการทำซ้ำมีจุดมุ่งหมาย เมื่อต้องรีบดำเนินการให้ตรงตามกำหนดเวลาและรหัสที่มีอยู่นั้น “เกือบถูกต้อง” สำหรับงานนี้โปรแกรมเมอร์มือใหม่อาจจะต้องใช้วิธีคัดลอกโค้ดที่เกี่ยวข้องได้ และในบางกรณีโปรแกรมเมอร์ก็ขี้เกียจเกินไปที่จะจัดการความยุ่งเหยิง
## Treatment(การรักษา)
หากพบรหัสเดียวกันในสองMethodหรือมากกว่าในคลาสเดียวกันให้ใช้ Extract Method และทำการเรียกใช้เมธอดใหม่ในทั้งสองที่
* หากพบรหัสเดียวกันในสองคลาสย่อยที่มีระดับเดียวกัน:
  * ใช้ Extract Method สำหรับทั้งสองคลาสตามด้วย Pull Up Field สำหรับฟิลด์ที่ใช้ในวิธีที่คุณกำลังดึงขึ้น
  * หากรหัสที่ซ้ำกันอยู่ภายในตัวสร้างให้ใช้ Pull Up Constructor Body
  * ถ้ารหัสที่ซ้ำกันคล้ายกัน แต่ไม่เหมือนกันโดยสิ้นเชิง ให้ใช้ Form Template Method
  * หากสองวิธีทำสิ่งเดียวกัน แต่ใช้อัลกอริทึมที่แตกต่างกันให้เลือกอัลกอริทึมที่ดีที่สุดและใช้อัลกอริทึมทดแทน
* หากพบรหัสที่ซ้ำกันในสองคลาสที่แตกต่างกัน:
  * ถ้าคลาสไม่ได้เป็นส่วนหนึ่งของลำดับชั้นให้ใช้ Extract Superclass เพื่อสร้าง superclass เดียวสำหรับคลาสเหล่านี้ที่รักษาการทำงานก่อนหน้านี้ทั้งหมด
  * หากสร้างคลาสระดับสูงได้ยากหรือเป็นไปไม่ได้ให้ใช้ Extract Class ในคลาสหนึ่งและใช้ส่วนประกอบใหม่ในอีกชั้นหนึ่ง
* หากมีส่วนที่เป็นเงื่อนไขจำนวนมากและอยู่ในโค้ดเดียวกัน (แตกต่างกันในเงื่อนไขเท่านั้น) ให้รวมเป็นเงื่อนไขเดียวโดยใช้ Consolidate Conditional Expression และใช้ Extract Method เพื่อวางเงื่อนไขในวิธีการแยกต่างหากด้วยวิธีที่ง่ายเพื่อเข้าใจชื่อMethod
* หากดำเนินการโค้ดเดียวกันในทุกส่วนที่เป็นเงื่อนไข ให้วางโค้ดที่เหมือนกันไว้ด้านนอกของโครงสร้างเงื่อนไขโดยใช้ Consolidate Duplicate Conditional Fragments
## Payoff (ผลตอบแทน)
* การรวมโค้ดที่ซ้ำกันทำให้โครงสร้างของโค้ดง่ายขึ้นและทำให้โค้ดสั้นลง
* ความเรียบง่าย + ความสั้น = โค้ดที่ง่ายต่อการลดความซับซ้อนและสนับสนุนง่ายกว่า
## When to Ignore (เมื่อใดควรละเว้น)
* ในบางกรณีซึ่งหายากมาก การรวมส่วนของโค้ดที่เหมือนกันสองชิ้นเข้าด้วยกันจะทำให้โค้ดใช้งานง่ายและชัดเจนมากขึ้น
# Lazy Class
## Signs and Symptoms(สัญญาณและอาการ)
* การทำความเข้าใจและการบำรุงรักษาชั้นเรียนนั้นต้องเสียเวลาและเงินเสมอ ดังนั้นหากชั้นเรียนไม่สามารถดึงดูดความสนใจของคุณได้มากพอ ก็ควรลบออก
## Reasons for the Problem(สาเหตุของปัญหา)
* บางทีชั้นเรียนอาจถูกออกแบบมาให้ใช้งานได้อย่างสมบูรณ์ แต่หลังจากการปรับโครงสร้างใหม่แล้วบางส่วนก็มีขนาดเล็กลง หรือบางทีออกแบบมาเพื่อรองรับงานพัฒนาในอนาคตที่ไม่เคยทำ
## Treatment(การรักษา)
* ส่วนประกอบที่ใกล้จะไร้ประโยชน์ควรได้รับการบำบัดแบบอินไลน์คลาส  โดยสำหรับคลาสย่อยที่มีฟังก์ชันน้อย ให้ลองยุบลำดับชั้น
## Payoff (ผลตอบแทน)
* ลดขนาดของโค้ด
* ง่ายต่อการบำรุงรักษาหรือเปลี่ยนแปลง
## When to Ignore (เมื่อใดควรละเว้น)
* บางครั้ง Lazy Class ถูกสร้างขึ้นเพื่อระบุความตั้งใจสำหรับการพัฒนาในอนาคตในกรณีนี้พยายามรักษาสมดุลระหว่างความชัดเจนและความเรียบง่ายในโค้ดของคุณ
# Data Class
## Signs and Symptoms(สัญญาณและอาการ)
* คลาสข้อมูลหมายถึงคลาสที่มีเฉพาะฟิลด์และเมธอดหยาบในการเข้าถึงเท่านั้น (getters และ setters) ซึ่งเป็นเพียงคอนเทนเนอร์สำหรับข้อมูลที่คลาสอื่นใช้ โดยคลาสเหล่านี้ไม่มีฟังก์ชันเพิ่มเติมใด ๆ และไม่สามารถดำเนินการกับข้อมูลที่ตนเองเป็นเจ้าของได้อย่างอิสระ
## Reasons for the Problem(สาเหตุของปัญหา)
* เป็นเรื่องปกติเมื่อชั้นเรียนที่สร้างขึ้นใหม่มีช่องสาธารณะเพียงไม่กี่ช่อง (และอาจมีผู้ได้รับ/ผู้ตั้งค่าเพียงไม่กี่ช่อง) แต่ความสามารถแท้จริงของออบเจ็กต์ก็คือสามารถมีประเภทพฤติกรรมหรือการดำเนินการกับข้อมูลได้
## Treatment(การรักษา)
* หากคลาสมีฟิลด์สาธารณะให้ใช้ Encapsulate Field เพื่อซ่อนไม่ให้เข้าถึงโดยตรง และกำหนดให้เข้าถึงได้ผ่าน getters และ setters เท่านั้น
* ใช้ Encapsulate Collection สำหรับข้อมูลที่จัดเก็บในคอลเลกชัน (เช่นอาร์เรย์)
* ตรวจทานรหัสไคลเอ็นต์ที่ใช้โดยคลาส ในนั้นคุณอาจพบฟังก์ชันการทำงานที่ดีกว่าในชั้นข้อมูลเอง หากเป็นกรณีนี้ให้ใช้ Move Method และ Extract Method เพื่อย้ายฟังก์ชันนี้ไปยังคลาสข้อมูล

หลังจากชั้นเรียนเต็มไปด้วยวิธีการที่คิดมาอย่างดีแล้วคุณอาจต้องการกำจัดวิธีการเก่า ๆ ในการเข้าถึงข้อมูลที่ให้การเข้าถึงข้อมูลชั้นเรียนในวงกว้างมากเกินไป สำหรับกรณีนี้วิธีอาจต้องใช้วิธีลบการตั้งค่าและวิธีซ่อน
## Payoff (ผลตอบแทน)
* เพิ่มความเข้าใจและจัดระเบียบรหัส ขณะนี้การดำเนินการกับข้อมูลเฉพาะจะถูกรวบรวมไว้ในที่เดียวแทนที่จะเป็นการส่งตลอดรหัส
* ช่วยให้คุณเห็นการซ้ำซ้อนของรหัสไคลเอนต์
# Dead Code
## Signs and Symptoms(สัญญาณและอาการ)
* การใช้ตัวแปรพารามิเตอร์ฟิลด์วิธีการหรือคลาสไม่ค่อยนิยมในสมัยนี้ (เพราะล้าสมัย)
## Reasons for the Problem(สาเหตุของปัญหา)
* เมื่อข้อกำหนดสำหรับซอฟต์แวร์มีการเปลี่ยนแปลงหรือมีการแก้ไขทำให้การเวลาจัดระเบียบโค้ดเดิมนั้นเป็นไปได้ยาก

รหัสดังกล่าวสามารถพบได้ในเงื่อนไขที่ซับซ้อนเมื่อหนึ่งในสาขาไม่สามารถเข้าถึงได้ (เนื่องจากข้อผิดพลาดหรือสถานการณ์อื่น ๆ )
## Treatment(การรักษา)
วิธีที่เร็วที่สุดในการค้นหารหัสที่ตายแล้วคือการใช้ IDE ที่ดีและลบรหัสที่ไม่ได้ใช้และไฟล์ที่ไม่จำเป็น
* ในกรณีของคลาสที่ไม่จำเป็นสามารถใช้ Inline Class หรือ Collapse Hierarchy ได้หากใช้ subclass หรือ superclass
* หากต้องการลบพารามิเตอร์ที่ไม่จำเป็นให้ใช้วิธี Remove Parameter
## Payoff (ผลตอบแทน)
* ลดขนาดโค้ด
* ทำให้โค้ดง่ายขึ้น
# Speculative Generality
## Signs and Symptoms(สัญญาณและอาการ)
* มีคลาสเมธอดฟิลด์หรือพารามิเตอร์ที่ไม่ได้ใช้
## Reasons for the Problem(สาเหตุของปัญหา)
* บางครั้งโค้ดจะถูกสร้างขึ้น "ในกรณี" ที่ต้องการการรองรับฟังก์ชันในอนาคตที่คาดการณ์ไว้ซึ่งจะไม่มีการใช้ ด้วยเหตุนี้โค้ดจึงยากที่จะเข้าใจและรองรับ
## Treatment(การรักษา)
สำหรับการลบคลาสไม่ได้ใช้ ให้ลองยุบลำดับชั้น
* การมอบหมายฟังก์ชันการทำงานที่ไม่จำเป็นไปยังคลาสอื่นสามารถกำจัดได้ผ่านทางอินไลน์คลาส
* ใช้วิธีการแบบอินไลน์เพื่อกำจัดวิธีการที่ไม่ได้ใช้
* วิธีการที่มีพารามิเตอร์ที่ไม่ได้ใช้ ควรดูด้วย Remove Parameter
* ช่องที่ไม่ได้ใช้สามารถลบได้ง่ายๆ
## Payoff (ผลตอบแทน)
* ทำให้โค้ดสั้นลง
* ง่ายต่อการสนับสนุน
## When to Ignore (เมื่อใดควรละเว้น)
* หากคุณกำลังทำงานกับเฟรมเวิร์กการสร้างฟังก์ชันที่ไม่ได้ใช้ในเฟรมเวิร์กนั้น เป็นเรื่องปกติเมื่อผู้ใช้ของเฟรมเวิร์กต้องการฟังก์ชันการทำงาน
* ก่อนลบองค์ประกอบ ตรวจสอบให้แน่ใจว่าไม่ได้ใช้ในการทดสอบ บางครั้งการทดสอบต้องการวิธีหรือข้อมูลในคลาสนั้นๆ


